package test

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"testing"
	"time"

	"github.com/han-fei/monitor/pkg/algorithm"
	"github.com/han-fei/monitor/pkg/agent"
	"github.com/han-fei/monitor/pkg/hash"
	"github.com/han-fei/monitor/pkg/queue"
	"github.com/han-fei/monitor/pkg/storage"
	"github.com/han-fei/monitor/internal/utils"
)

// TestSuite æµ‹è¯•å¥—ä»¶
type TestSuite struct {
	Name        string
	Setup       func() error
	Teardown    func() error
	TestCases   []TestCase
}

// TestCase æµ‹è¯•ç”¨ä¾‹
type TestCase struct {
	Name     string
	TestFunc func(*testing.T) error
}

// TestRunner æµ‹è¯•è¿è¡Œå™¨
type TestRunner struct {
	suites      []*TestSuite
	results     []*TestResult
	currentDir  string
	logFile     *os.File
	errorLog    *os.File
}

// TestResult æµ‹è¯•ç»“æœ
type TestResult struct {
	SuiteName   string
	TestCase    string
	Passed      bool
	Error       error
	Duration    time.Duration
	LogFile     string
}

// NewTestRunner åˆ›å»ºæ–°çš„æµ‹è¯•è¿è¡Œå™¨
func NewTestRunner() (*TestRunner, error) {
	// åˆ›å»ºæ—¥å¿—ç›®å½•
	logDir := "logs/tests"
	if err := os.MkdirAll(logDir, 0755); err != nil {
		return nil, fmt.Errorf("åˆ›å»ºæ—¥å¿—ç›®å½•å¤±è´¥: %v", err)
	}
	
	// åˆ›å»ºæ—¥å¿—æ–‡ä»¶
	timestamp := time.Now().Format("20060102_150405")
	logPath := filepath.Join(logDir, fmt.Sprintf("test_%s.log", timestamp))
	logFile, err := os.Create(logPath)
	if err != nil {
		return nil, fmt.Errorf("åˆ›å»ºæ—¥å¿—æ–‡ä»¶å¤±è´¥: %v", err)
	}
	
	// åˆ›å»ºé”™è¯¯æ—¥å¿—æ–‡ä»¶
	errorLogPath := filepath.Join(logDir, fmt.Sprintf("error_%s.log", timestamp))
	errorLogFile, err := os.Create(errorLogPath)
	if err != nil {
		logFile.Close()
		return nil, fmt.Errorf("åˆ›å»ºé”™è¯¯æ—¥å¿—æ–‡ä»¶å¤±è´¥: %v", err)
	}
	
	runner := &TestRunner{
		suites:     make([]*TestSuite, 0),
		results:    make([]*TestResult, 0),
		currentDir: "",
		logFile:    logFile,
		errorLog:   errorLogFile,
	}
	
	return runner, nil
}

// AddSuite æ·»åŠ æµ‹è¯•å¥—ä»¶
func (tr *TestRunner) AddSuite(suite *TestSuite) {
	tr.suites = append(tr.suites, suite)
}

// Run è¿è¡Œæ‰€æœ‰æµ‹è¯•
func (tr *TestRunner) Run() []*TestResult {
	for _, suite := range tr.suites {
		tr.runSuite(suite)
	}
	
	return tr.results
}

// runSuite è¿è¡Œæµ‹è¯•å¥—ä»¶
func (tr *TestRunner) runSuite(suite *TestSuite) {
	log.Printf("è¿è¡Œæµ‹è¯•å¥—ä»¶: %s", suite.Name)
	
	// è®¾ç½®
	if suite.Setup != nil {
		if err := suite.Setup(); err != nil {
			log.Printf("æµ‹è¯•å¥—ä»¶ %s è®¾ç½®å¤±è´¥: %v", suite.Name, err)
			return
		}
	}
	
	// è¿è¡Œæµ‹è¯•ç”¨ä¾‹
	for _, testCase := range suite.TestCases {
		result := tr.runTestCase(suite, &testCase)
		tr.results = append(tr.results, result)
	}
	
	// æ¸…ç†
	if suite.Teardown != nil {
		if err := suite.Teardown(); err != nil {
			log.Printf("æµ‹è¯•å¥—ä»¶ %s æ¸…ç†å¤±è´¥: %v", suite.Name, err)
		}
	}
}

// runTestCase è¿è¡Œæµ‹è¯•ç”¨ä¾‹
func (tr *TestRunner) runTestCase(suite *TestSuite, testCase *TestCase) *TestResult {
	result := &TestResult{
		SuiteName: suite.Name,
		TestCase:  testCase.Name,
		Passed:    false,
		Duration:  0,
	}
	
	startTime := time.Now()
	
	// åˆ›å»ºæµ‹è¯•ä¸Šä¸‹æ–‡
	test := &testing.T{}
	
	// è¿è¡Œæµ‹è¯•å‡½æ•°
	err := testCase.TestFunc(test)
	
	result.Duration = time.Since(startTime)
	result.Passed = err == nil
	result.Error = err
	
	if err != nil {
		log.Printf("æµ‹è¯•å¤±è´¥: %s.%s - %v", suite.Name, testCase.Name, err)
		// è®°å½•é”™è¯¯åˆ°é”™è¯¯æ—¥å¿—
		fmt.Fprintf(tr.errorLog, "æµ‹è¯•å¤±è´¥: %s.%s - %v\n", suite.Name, testCase.Name, err)
		fmt.Fprintf(tr.errorLog, "å †æ ˆä¿¡æ¯:\n%s\n", getStackTrace())
	} else {
		log.Printf("æµ‹è¯•é€šè¿‡: %s.%s", suite.Name, testCase.Name)
	}
	
	// è®°å½•ç»“æœåˆ°æ—¥å¿—
	fmt.Fprintf(tr.logFile, "æµ‹è¯•: %s.%s - %v - è€—æ—¶: %v\n", 
		suite.Name, testCase.Name, result.Passed, result.Duration)
	
	return result
}

// Close å…³é—­æµ‹è¯•è¿è¡Œå™¨
func (tr *TestRunner) Close() error {
	if tr.logFile != nil {
		tr.logFile.Close()
	}
	if tr.errorLog != nil {
		tr.errorLog.Close()
	}
	return nil
}

// getStackTrace è·å–å †æ ˆä¿¡æ¯
func getStackTrace() string {
	buf := make([]byte, 4096)
	n := runtime.Stack(buf, false)
	return string(buf[:n])
}

// AlgorithmTests ç®—æ³•æµ‹è¯•å¥—ä»¶
func AlgorithmTests() *TestSuite {
	return &TestSuite{
		Name: "AlgorithmTests",
		Setup: func() error {
			log.Println("è®¾ç½®ç®—æ³•æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†ç®—æ³•æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestSlidingWindow",
				TestFunc: func(t *testing.T) error {
					window := algorithm.NewAdaptiveSlidingWindow(100, time.Hour, true)
					
					// æµ‹è¯•æ·»åŠ æ•°æ®
					for i := 0; i < 50; i++ {
						window.Add(float64(i))
					}
					
					// æµ‹è¯•ç»Ÿè®¡
					stats := window.GetStats()
					if stats["count"] != 50 {
						return fmt.Errorf("æœŸæœ›50ä¸ªæ•°æ®ç‚¹ï¼Œå®é™…è·å¾—%d", int(stats["count"]))
					}
					
					// æµ‹è¯•å¹³å‡å€¼
					avg := window.Average()
					expectedAvg := 24.5 // (0+49)/2
					if avg != expectedAvg {
						return fmt.Errorf("æœŸæœ›å¹³å‡å€¼%.1fï¼Œå®é™…è·å¾—%.1f", expectedAvg, avg)
					}
					
					return nil
				},
			},
			{
				Name: "TestTimeWheel",
				TestFunc: func(t *testing.T) error {
					timeWheel := algorithm.NewTimeWheel(time.Second, 60)
					
					// åˆ›å»ºæµ‹è¯•ä»»åŠ¡
					task := &TestTask{executed: false}
					
					// æ·»åŠ ä»»åŠ¡
					timeWheel.AddTask(time.Second, "test", task)
					
					// å¯åŠ¨æ—¶é—´è½®
					timeWheel.Start()
					
					// ç­‰å¾…ä»»åŠ¡æ‰§è¡Œ
					time.Sleep(2 * time.Second)
					
					// æ£€æŸ¥ä»»åŠ¡æ˜¯å¦æ‰§è¡Œ
					if !task.executed {
						return fmt.Errorf("ä»»åŠ¡æœªæ‰§è¡Œ")
					}
					
					timeWheel.Stop()
					return nil
				},
			},
			{
				Name: "TestBloomFilter",
				TestFunc: func(t *testing.T) error {
					bloomFilter := algorithm.NewBloomFilter(1000, 3)
					
					// æ·»åŠ å…ƒç´ 
					testItems := []string{"item1", "item2", "item3"}
					for _, item := range testItems {
						bloomFilter.AddString(item)
					}
					
					// æµ‹è¯•å­˜åœ¨çš„å…ƒç´ 
					for _, item := range testItems {
						if !bloomFilter.TestString(item) {
							return fmt.Errorf("å…ƒç´  %s åº”è¯¥å­˜åœ¨", item)
						}
					}
					
					// æµ‹è¯•ä¸å­˜åœ¨çš„å…ƒç´ 
					if bloomFilter.TestString("nonexistent") {
						return fmt.Errorf("ä¸å­˜åœ¨çš„å…ƒç´ ä¸åº”è¯¥è¢«æ£€æµ‹åˆ°")
					}
					
					return nil
				},
			},
		},
	}
}

// TestTask æµ‹è¯•ä»»åŠ¡
type TestTask struct {
	executed bool
}

func (t *TestTask) Execute() {
	t.executed = true
}

// HashTests å“ˆå¸Œæµ‹è¯•å¥—ä»¶
func HashTests() *TestSuite {
	return &TestSuite{
		Name: "HashTests",
		Setup: func() error {
			log.Println("è®¾ç½®å“ˆå¸Œæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†å“ˆå¸Œæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestConsistentHash",
				TestFunc: func(t *testing.T) error {
					hashRing := hash.NewConsistentHash(3, nil)
					
					// æ·»åŠ èŠ‚ç‚¹
					nodes := []string{"node1", "node2", "node3"}
					hashRing.Add(nodes...)
					
					// æµ‹è¯•æ•°æ®åˆ†å¸ƒ
					distribution := make(map[string]int)
					for i := 0; i < 1000; i++ {
						key := fmt.Sprintf("key%d", i)
						node, err := hashRing.Get(key)
						if err != nil {
							return fmt.Errorf("è·å–èŠ‚ç‚¹å¤±è´¥: %v", err)
						}
						distribution[node]++
					}
					
					// æ£€æŸ¥åˆ†å¸ƒæ˜¯å¦åˆç†
					if len(distribution) != len(nodes) {
						return fmt.Errorf("æœŸæœ›åˆ†å¸ƒåˆ°%dä¸ªèŠ‚ç‚¹ï¼Œå®é™…åˆ†å¸ƒåˆ°%dä¸ª", len(nodes), len(distribution))
					}
					
					// æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰æ•°æ®
					for _, node := range nodes {
						if distribution[node] == 0 {
							return fmt.Errorf("èŠ‚ç‚¹ %s æ²¡æœ‰æ•°æ®", node)
						}
					}
					
					return nil
				},
			},
		},
	}
}

// QueueTests é˜Ÿåˆ—æµ‹è¯•å¥—ä»¶
func QueueTests() *TestSuite {
	return &TestSuite{
		Name: "QueueTests",
		Setup: func() error {
			log.Println("è®¾ç½®é˜Ÿåˆ—æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†é˜Ÿåˆ—æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestMessageQueue",
				TestFunc: func(t *testing.T) error {
					// åˆ›å»ºRediså­˜å‚¨ï¼ˆæ¨¡æ‹Ÿï¼‰
					redisConfig := storage.RedisConfig{
						Address: "localhost:6379",
						DB:      1,
					}
					
					redisStorage, err := storage.NewRedisStorage(redisConfig)
					if err != nil {
						log.Printf("Redisè¿æ¥å¤±è´¥ï¼Œè·³è¿‡é˜Ÿåˆ—æµ‹è¯•: %v", err)
						return nil // è·³è¿‡æµ‹è¯•è€Œä¸æ˜¯å¤±è´¥
					}
					
					messageQueue := queue.NewRedisMessageQueue(redisStorage, "test", time.Hour)
					
					// åˆ›å»ºæµ‹è¯•æ¶ˆæ¯
					message := &queue.Message{
						ID:        "test1",
						Topic:     "test",
						Payload:   []byte("test payload"),
						Timestamp: time.Now(),
					}
					
					// å‘å¸ƒæ¶ˆæ¯
					ctx := context.Background()
					err = messageQueue.Publish(ctx, "test", message)
					if err != nil {
						return fmt.Errorf("å‘å¸ƒæ¶ˆæ¯å¤±è´¥: %v", err)
					}
					
					// è·å–ç»Ÿè®¡ä¿¡æ¯
					stats, err := messageQueue.GetStats(ctx)
					if err != nil {
						return fmt.Errorf("è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: %v", err)
					}
					
					if stats.TotalMessages != 1 {
						return fmt.Errorf("æœŸæœ›1æ¡æ¶ˆæ¯ï¼Œå®é™…è·å¾—%dæ¡", stats.TotalMessages)
					}
					
					return nil
				},
			},
		},
	}
}

// UtilsTests å·¥å…·æµ‹è¯•å¥—ä»¶
func UtilsTests() *TestSuite {
	return &TestSuite{
		Name: "UtilsTests",
		Setup: func() error {
			log.Println("è®¾ç½®å·¥å…·æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†å·¥å…·æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestCircuitBreaker",
				TestFunc: func(t *testing.T) error {
					cb := utils.NewCircuitBreaker(3, time.Second)
					
					// æµ‹è¯•æ­£å¸¸æ“ä½œ
					err := cb.Execute(func() error {
						return nil
					})
					if err != nil {
						return fmt.Errorf("ç†”æ–­å™¨åº”è¯¥å…è®¸æ­£å¸¸æ“ä½œ")
					}
					
					// æµ‹è¯•å¤±è´¥æ“ä½œ
					for i := 0; i < 3; i++ {
						err = cb.Execute(func() error {
							return fmt.Errorf("æµ‹è¯•é”™è¯¯")
						})
						if err == nil {
							return fmt.Errorf("åº”è¯¥è¿”å›é”™è¯¯")
						}
					}
					
					// æ£€æŸ¥ç†”æ–­å™¨æ˜¯å¦æ‰“å¼€
					if cb.GetState() != "open" {
						return fmt.Errorf("ç†”æ–­å™¨åº”è¯¥æ‰“å¼€")
					}
					
					return nil
				},
			},
			{
				Name: "TestRateLimiter",
				TestFunc: func(t *testing.T) error {
					limiter := utils.NewRateLimiter(10, 10)
					
					// æµ‹è¯•é€Ÿç‡é™åˆ¶
					allowed := 0
					for i := 0; i < 15; i++ {
						if limiter.Allow() {
							allowed++
						}
						time.Sleep(10 * time.Millisecond)
					}
					
					if allowed > 10 {
						return fmt.Errorf("é€Ÿç‡é™åˆ¶å™¨åº”è¯¥é™åˆ¶åœ¨10æ¬¡ä»¥å†…")
					}
					
					return nil
				},
			},
			{
				Name: "TestRetryPolicy",
				TestFunc: func(t *testing.T) error {
					policy := utils.NewRetryPolicy(3, time.Millisecond, time.Millisecond, 2.0)
					
					attempts := 0
					err := policy.ExecuteWithRetry(func() error {
						attempts++
						if attempts < 3 {
							return fmt.Errorf("ä¸´æ—¶é”™è¯¯")
						}
						return nil
					})
					
					if err != nil {
						return fmt.Errorf("é‡è¯•åº”è¯¥æˆåŠŸ")
					}
					
					if attempts != 3 {
						return fmt.Errorf("æœŸæœ›3æ¬¡å°è¯•ï¼Œå®é™…%dæ¬¡", attempts)
					}
					
					return nil
				},
			},
		},
	}
}

// ConfigTests é…ç½®æµ‹è¯•å¥—ä»¶
func ConfigTests() *TestSuite {
	return &TestSuite{
		Name: "ConfigTests",
		Setup: func() error {
			log.Println("è®¾ç½®é…ç½®æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†é…ç½®æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestConfigLoading",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•é…ç½®æ–‡ä»¶åŠ è½½
					cfg, err := config.LoadConfig("configs/agent.yaml")
					if err != nil {
						return fmt.Errorf("åŠ è½½é…ç½®å¤±è´¥: %v", err)
					}
					
					// æ£€æŸ¥é…ç½®å€¼
					if cfg.Agent.HostID == "" {
						return fmt.Errorf("HostIDä¸åº”è¯¥ä¸ºç©º")
					}
					
					if cfg.Collect.Interval <= 0 {
						return fmt.Errorf("é‡‡é›†é—´éš”åº”è¯¥å¤§äº0")
					}
					
					return nil
				},
			},
		},
	}
}

// IntegrationTests é›†æˆæµ‹è¯•å¥—ä»¶
func IntegrationTests() *TestSuite {
	return &TestSuite{
		Name: "IntegrationTests",
		Setup: func() error {
			log.Println("è®¾ç½®é›†æˆæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†é›†æˆæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestAlgorithmManager",
				TestFunc: func(t *testing.T) error {
					// åŠ è½½é…ç½®
					cfg, err := config.LoadConfig("configs/agent.yaml")
					if err != nil {
						return fmt.Errorf("åŠ è½½é…ç½®å¤±è´¥: %v", err)
					}
					
					// åˆ›å»ºç®—æ³•ç®¡ç†å™¨
					manager := algorithm.NewAlgorithmManager(cfg)
					
					// å¯åŠ¨ç®¡ç†å™¨
					err = manager.Start()
					if err != nil {
						return fmt.Errorf("å¯åŠ¨ç®—æ³•ç®¡ç†å™¨å¤±è´¥: %v", err)
					}
					
					// æµ‹è¯•æ»‘åŠ¨çª—å£
					err = manager.AddSlidingWindowValue("cpu", 50.0)
					if err != nil {
						return fmt.Errorf("æ·»åŠ æ»‘åŠ¨çª—å£å€¼å¤±è´¥: %v", err)
					}
					
					// æµ‹è¯•å¸ƒéš†è¿‡æ»¤å™¨
					manager.AddToBloomFilter("test_host")
					if !manager.TestBloomFilter("test_host") {
						return fmt.Errorf("å¸ƒéš†è¿‡æ»¤å™¨åº”è¯¥åŒ…å«test_host")
					}
					
					// è·å–ç»Ÿè®¡ä¿¡æ¯
					stats := manager.GetStats()
					if stats == nil {
						return fmt.Errorf("ç»Ÿè®¡ä¿¡æ¯ä¸åº”è¯¥ä¸ºç©º")
					}
					
					// åœæ­¢ç®¡ç†å™¨
					manager.Stop()
					
					return nil
				},
			},
		},
	}
}

// RunAllTests è¿è¡Œæ‰€æœ‰æµ‹è¯•
func RunAllTests() error {
	runner, err := NewTestRunner()
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæµ‹è¯•è¿è¡Œå™¨å¤±è´¥: %v", err)
	}
	defer runner.Close()
	
	// æ·»åŠ æµ‹è¯•å¥—ä»¶
	runner.AddSuite(AlgorithmTests())
	runner.AddSuite(HashTests())
	runner.AddSuite(QueueTests())
	runner.AddSuite(UtilsTests())
	runner.AddSuite(ConfigTests())
	runner.AddSuite(IntegrationTests())
	
	// è¿è¡Œæµ‹è¯•
	results := runner.Run()
	
	// ç»Ÿè®¡ç»“æœ
	total := len(results)
	passed := 0
	failed := 0
	
	for _, result := range results {
		if result.Passed {
			passed++
		} else {
			failed++
		}
	}
	
	// è¾“å‡ºç»“æœ
	fmt.Printf("\næµ‹è¯•ç»“æœæ±‡æ€»:\n")
	fmt.Printf("æ€»æµ‹è¯•æ•°: %d\n", total)
	fmt.Printf("é€šè¿‡: %d\n", passed)
	fmt.Printf("å¤±è´¥: %d\n", failed)
	fmt.Printf("æˆåŠŸç‡: %.1f%%\n", float64(passed)/float64(total)*100)
	
	if failed > 0 {
		fmt.Printf("\nå¤±è´¥çš„æµ‹è¯•:\n")
		for _, result := range results {
			if !result.Passed {
				fmt.Printf("- %s.%s: %v\n", result.SuiteName, result.TestCase, result.Error)
			}
		}
		return fmt.Errorf("æœ‰%dä¸ªæµ‹è¯•å¤±è´¥", failed)
	}
	
	fmt.Printf("\nğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\n")
	return nil
}