package test

import (
	"fmt"
	"log"
	"os"
	"runtime"
	"sync"
	"testing"
	"time"
)

// EnhancedAgentTests å¢å¼ºçš„Agentæµ‹è¯•å¥—ä»¶
func EnhancedAgentTests() *TestSuite {
	return &TestSuite{
		Name: "EnhancedAgentTests",
		Setup: func() error {
			log.Println("è®¾ç½®å¢å¼ºAgentæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†å¢å¼ºAgentæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestMetricsDataStructure",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•æŒ‡æ ‡æ•°æ®ç»“æ„çš„åŸºæœ¬åŠŸèƒ½
					// è¿™é‡Œæˆ‘ä»¬æµ‹è¯•æ•°æ®ç»“æ„çš„æ¦‚å¿µï¼Œè€Œä¸æ˜¯å…·ä½“çš„å®ç°
					
					// æ¨¡æ‹ŸæŒ‡æ ‡æ•°æ®
					type Metric struct {
						Name  string
						Value float64
					}
					
					type MetricsData struct {
						HostID    string
						Timestamp time.Time
						Metrics   []Metric
					}
					
					// åˆ›å»ºæµ‹è¯•æ•°æ®
					data := MetricsData{
						HostID:    "test-host",
						Timestamp: time.Now(),
						Metrics: []Metric{
							{Name: "cpu_usage", Value: 45.5},
							{Name: "memory_usage", Value: 1024.0},
							{Name: "network_rx", Value: 1000000.0},
						},
					}
					
					// éªŒè¯æ•°æ®
					if data.HostID == "" {
						return fmt.Errorf("HostIDä¸åº”è¯¥ä¸ºç©º")
					}
					
					if data.Timestamp.IsZero() {
						return fmt.Errorf("Timestampä¸åº”è¯¥ä¸ºé›¶")
					}
					
					if len(data.Metrics) == 0 {
						return fmt.Errorf("Metricsä¸åº”è¯¥ä¸ºç©º")
					}
					
					// éªŒè¯æŒ‡æ ‡å€¼
					for _, metric := range data.Metrics {
						if metric.Name == "" {
							return fmt.Errorf("æŒ‡æ ‡åç§°ä¸åº”è¯¥ä¸ºç©º")
						}
						if metric.Value < 0 {
							return fmt.Errorf("æŒ‡æ ‡å€¼ä¸åº”è¯¥ä¸ºè´Ÿæ•°")
						}
					}
					
					return nil
				},
			},
			{
				Name: "TestDataCollectionSimulation",
				TestFunc: func(t *testing.T) error {
					// æ¨¡æ‹Ÿæ•°æ®é‡‡é›†è¿‡ç¨‹
					
					// æ¨¡æ‹Ÿé‡‡é›†é—´éš”
					interval := 100 * time.Millisecond
					collections := 10
					
					var collectedData []time.Time
					var mu sync.Mutex
					
					// æ¨¡æ‹Ÿå¹¶å‘é‡‡é›†
					var wg sync.WaitGroup
					for i := 0; i < 3; i++ {
						wg.Add(1)
						go func(collectorID int) {
							defer wg.Done()
							
							for j := 0; j < collections; j++ {
								// æ¨¡æ‹Ÿé‡‡é›†è€—æ—¶
								time.Sleep(interval / 2)
								
								mu.Lock()
								collectedData = append(collectedData, time.Now())
								mu.Unlock()
								
								time.Sleep(interval / 2)
							}
						}(i)
					}
					
					wg.Wait()
					
					// éªŒè¯é‡‡é›†æ•°æ®
					expectedCollections := 3 * collections
					if len(collectedData) != expectedCollections {
						return fmt.Errorf("æœŸæœ›é‡‡é›† %d æ¬¡æ•°æ®ï¼Œå®é™…é‡‡é›† %d æ¬¡", 
							expectedCollections, len(collectedData))
					}
					
					// éªŒè¯æ—¶é—´åˆ†å¸ƒ
					if len(collectedData) > 1 {
						firstTime := collectedData[0]
						lastTime := collectedData[len(collectedData)-1]
						duration := lastTime.Sub(firstTime)
						
						// é‡‡é›†åº”è¯¥åœ¨åˆç†æ—¶é—´å†…å®Œæˆ
						expectedDuration := time.Duration(collections) * interval
						if duration > expectedDuration*2 {
							return fmt.Errorf("é‡‡é›†æ—¶é—´è¿‡é•¿ï¼ŒæœŸæœ›çº¦ %vï¼Œå®é™… %v", 
								expectedDuration, duration)
						}
					}
					
					return nil
				},
			},
			{
				Name: "TestConfigurationValidation",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•é…ç½®éªŒè¯é€»è¾‘
					
					// æ¨¡æ‹Ÿé…ç½®ç»“æ„
					type AgentConfig struct {
						HostID     string
						BrokerAddr string
						Interval   time.Duration
					}
					
					// æµ‹è¯•æœ‰æ•ˆé…ç½®
					validConfigs := []AgentConfig{
						{
							HostID:     "agent-1",
							BrokerAddr: "localhost:9093",
							Interval:   time.Second,
						},
						{
							HostID:     "agent-2",
							BrokerAddr: "192.168.1.100:9093",
							Interval:   5 * time.Second,
						},
					}
					
					for i, config := range validConfigs {
						if config.HostID == "" {
							return fmt.Errorf("é…ç½® %d: HostIDä¸åº”è¯¥ä¸ºç©º", i)
						}
						if config.BrokerAddr == "" {
							return fmt.Errorf("é…ç½® %d: BrokerAddrä¸åº”è¯¥ä¸ºç©º", i)
						}
						if config.Interval <= 0 {
							return fmt.Errorf("é…ç½® %d: Intervalåº”è¯¥å¤§äº0", i)
						}
					}
					
					// æµ‹è¯•æ— æ•ˆé…ç½®
					invalidConfigs := []AgentConfig{
						{HostID: "", BrokerAddr: "localhost:9093", Interval: time.Second},
						{HostID: "agent-1", BrokerAddr: "", Interval: time.Second},
						{HostID: "agent-1", BrokerAddr: "localhost:9093", Interval: 0},
					}
					
					for i, config := range invalidConfigs {
						errors := 0
						if config.HostID == "" {
							errors++
						}
						if config.BrokerAddr == "" {
							errors++
						}
						if config.Interval <= 0 {
							errors++
						}
						if errors == 0 {
							return fmt.Errorf("é…ç½® %d åº”è¯¥è¢«æ ‡è®°ä¸ºæ— æ•ˆ", i)
						}
					}
					
					return nil
				},
			},
		},
	}
}

// EnhancedBrokerTests å¢å¼ºçš„Brokeræµ‹è¯•å¥—ä»¶
func EnhancedBrokerTests() *TestSuite {
	return &TestSuite{
		Name: "EnhancedBrokerTests",
		Setup: func() error {
			log.Println("è®¾ç½®å¢å¼ºBrokeræµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†å¢å¼ºBrokeræµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestConsistentHashSimulation",
				TestFunc: func(t *testing.T) error {
					// æ¨¡æ‹Ÿä¸€è‡´æ€§å“ˆå¸Œç®—æ³•
					
					// ç®€å•çš„å“ˆå¸Œå‡½æ•°æ¨¡æ‹Ÿ
					simpleHash := func(key string) int {
						hash := 0
						for _, c := range key {
							hash = (hash << 5) + hash + int(c)
						}
						return hash
					}
					
					// æ¨¡æ‹ŸèŠ‚ç‚¹
					nodes := []string{"node-1", "node-2", "node-3"}
					
					// æµ‹è¯•æ•°æ®åˆ†å¸ƒ
					distribution := make(map[string]int)
					testKeys := 1000
					
					for i := 0; i < testKeys; i++ {
						key := fmt.Sprintf("key-%d", i)
						hash := simpleHash(key)
						nodeIndex := hash % len(nodes)
						selectedNode := nodes[nodeIndex]
						distribution[selectedNode]++
					}
					
					// éªŒè¯åˆ†å¸ƒ
					if len(distribution) != len(nodes) {
						return fmt.Errorf("æœŸæœ›åˆ†å¸ƒåˆ°%dä¸ªèŠ‚ç‚¹ï¼Œå®é™…åˆ†å¸ƒåˆ°%dä¸ª", 
							len(nodes), len(distribution))
					}
					
					// éªŒè¯æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰æ•°æ®
					for _, node := range nodes {
						if distribution[node] == 0 {
							return fmt.Errorf("èŠ‚ç‚¹ %s æ²¡æœ‰æ•°æ®", node)
						}
					}
					
					// éªŒè¯è´Ÿè½½å‡è¡¡
					expectedPerNode := testKeys / len(nodes)
					tolerance := expectedPerNode / 3 // 33%å®¹é”™
					
					for _, node := range nodes {
						count := distribution[node]
						if count < expectedPerNode-tolerance || count > expectedPerNode+tolerance {
							return fmt.Errorf("èŠ‚ç‚¹ %s è´Ÿè½½ä¸å‡è¡¡ï¼ŒæœŸæœ› %dÂ±%dï¼Œå®é™… %d", 
								node, expectedPerNode, tolerance, count)
						}
					}
					
					return nil
				},
			},
			{
				Name: "TestMessageQueueSimulation",
				TestFunc: func(t *testing.T) error {
					// æ¨¡æ‹Ÿæ¶ˆæ¯é˜Ÿåˆ—æ“ä½œ
					
					type Message struct {
						ID        string
						Topic     string
						Payload   []byte
						Timestamp time.Time
					}
					
					// æ¨¡æ‹Ÿæ¶ˆæ¯é˜Ÿåˆ—
					queue := make(chan Message, 100)
					
					// ç”Ÿäº§è€…
					messagesToSend := 50
					go func() {
						for i := 0; i < messagesToSend; i++ {
							msg := Message{
								ID:        fmt.Sprintf("msg-%d", i),
								Topic:     "test-topic",
								Payload:   []byte(fmt.Sprintf("payload-%d", i)),
								Timestamp: time.Now(),
							}
							queue <- msg
						}
						close(queue)
					}()
					
					// æ¶ˆè´¹è€…
					messagesReceived := 0
					for msg := range queue {
						if msg.ID == "" {
							return fmt.Errorf("æ¶ˆæ¯IDä¸åº”è¯¥ä¸ºç©º")
						}
						if len(msg.Payload) == 0 {
							return fmt.Errorf("æ¶ˆæ¯è½½è·ä¸åº”è¯¥ä¸ºç©º")
						}
						messagesReceived++
					}
					
					if messagesReceived != messagesToSend {
						return fmt.Errorf("æœŸæœ›æ¥æ”¶ %d æ¡æ¶ˆæ¯ï¼Œå®é™…æ¥æ”¶ %d æ¡", 
							messagesToSend, messagesReceived)
					}
					
					return nil
				},
			},
			{
				Name: "TestHostRegistrySimulation",
				TestFunc: func(t *testing.T) error {
					// æ¨¡æ‹Ÿä¸»æœºæ³¨å†Œè¡¨
					
					type HostInfo struct {
						ID       string
						Address  string
						Port     int
						Status   string
						LastSeen time.Time
					}
					
					// æ¨¡æ‹Ÿä¸»æœºæ³¨å†Œè¡¨
					registry := make(map[string]HostInfo)
					var mu sync.RWMutex
					
					// æ³¨å†Œä¸»æœº
					hosts := []HostInfo{
						{
							ID:      "host-1",
							Address: "192.168.1.100",
							Port:    9093,
							Status:  "healthy",
						},
						{
							ID:      "host-2",
							Address: "192.168.1.101",
							Port:    9093,
							Status:  "healthy",
						},
					}
					
					for _, host := range hosts {
						host.LastSeen = time.Now()
						mu.Lock()
						registry[host.ID] = host
						mu.Unlock()
					}
					
					// éªŒè¯ä¸»æœºæ³¨å†Œ
					mu.RLock()
					if len(registry) != len(hosts) {
						mu.RUnlock()
						return fmt.Errorf("æœŸæœ›æ³¨å†Œ %d ä¸ªä¸»æœºï¼Œå®é™…æ³¨å†Œ %d ä¸ª", 
							len(hosts), len(registry))
					}
					
					// éªŒè¯ä¸»æœºä¿¡æ¯
					for _, expected := range hosts {
						actual, exists := registry[expected.ID]
						if !exists {
							mu.RUnlock()
							return fmt.Errorf("ä¸»æœº %s æœªæ³¨å†Œ", expected.ID)
						}
						if actual.Address != expected.Address {
							mu.RUnlock()
							return fmt.Errorf("ä¸»æœº %s åœ°å€ä¸åŒ¹é…", expected.ID)
						}
					}
					mu.RUnlock()
					
					return nil
				},
			},
		},
	}
}

// EnhancedPerformanceTests å¢å¼ºçš„æ€§èƒ½æµ‹è¯•å¥—ä»¶
func EnhancedPerformanceTests() *TestSuite {
	return &TestSuite{
		Name: "EnhancedPerformanceTests",
		Setup: func() error {
			log.Println("è®¾ç½®å¢å¼ºæ€§èƒ½æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†å¢å¼ºæ€§èƒ½æµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestConcurrentProcessing",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•å¹¶å‘å¤„ç†èƒ½åŠ›
					
					concurrency := 10
					iterations := 100
					
					var wg sync.WaitGroup
					errors := make(chan error, concurrency)
					
					startTime := time.Now()
					
					for i := 0; i < concurrency; i++ {
						wg.Add(1)
						go func(workerID int) {
							defer wg.Done()
							
							for j := 0; j < iterations; j++ {
								// æ¨¡æ‹Ÿä¸€äº›è®¡ç®—å·¥ä½œ
								result := 0
								for k := 0; k < 1000; k++ {
									result += k
								}
								
								// æ¨¡æ‹Ÿä¸€äº›å»¶è¿Ÿ
								time.Sleep(time.Millisecond)
								
								if result == 0 { // é˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–
									errors <- fmt.Errorf("worker %d: è®¡ç®—é”™è¯¯", workerID)
									return
								}
							}
						}(i)
					}
					
					wg.Wait()
					close(errors)
					
					duration := time.Since(startTime)
					
					// æ£€æŸ¥é”™è¯¯
					for err := range errors {
						return err
					}
					
					// æ€§èƒ½éªŒè¯
					operations := concurrency * iterations
					opsPerSecond := float64(operations) / duration.Seconds()
					
					log.Printf("å¹¶å‘å¤„ç†æ€§èƒ½: %.0f ops/sec", opsPerSecond)
					
					// åº”è¯¥èƒ½å¤Ÿå¤„ç†è‡³å°‘1000 ops/sec
					if opsPerSecond < 1000 {
						return fmt.Errorf("å¹¶å‘å¤„ç†æ€§èƒ½ä¸è¶³: %.0f ops/sec < 1000 ops/sec", 
							opsPerSecond)
					}
					
					return nil
				},
			},
			{
				Name: "TestMemoryUsage",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ
					var m1, m2 runtime.MemStats
					runtime.GC()
					runtime.ReadMemStats(&m1)
					
					// åˆ›å»ºå¤§é‡æ•°æ®
					data := make([][]float64, 1000)
					for i := range data {
						data[i] = make([]float64, 1000)
						for j := range data[i] {
							data[i][j] = float64(i * j)
						}
					}
					
					runtime.GC()
					runtime.ReadMemStats(&m2)
					
					memoryUsed := m2.Alloc - m1.Alloc
					log.Printf("å†…å­˜ä½¿ç”¨: %d bytes", memoryUsed)
					
					// å†…å­˜åº”è¯¥åœ¨åˆç†èŒƒå›´å†…
					if memoryUsed > 100*1024*1024 { // 100MB
						return fmt.Errorf("å†…å­˜ä½¿ç”¨è¿‡å¤š: %d bytes", memoryUsed)
					}
					
					return nil
				},
			},
			{
				Name: "TestDataStructurePerformance",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•æ•°æ®ç»“æ„æ€§èƒ½
					
					// æµ‹è¯•mapæ“ä½œ
					startTime := time.Now()
					
					testMap := make(map[string]int)
					for i := 0; i < 10000; i++ {
						key := fmt.Sprintf("key-%d", i)
						testMap[key] = i
					}
					
					for i := 0; i < 10000; i++ {
						key := fmt.Sprintf("key-%d", i)
						_ = testMap[key]
					}
					
					mapDuration := time.Since(startTime)
					log.Printf("Mapæ“ä½œè€—æ—¶: %v", mapDuration)
					
					// æµ‹è¯•sliceæ“ä½œ
					startTime = time.Now()
					
					testSlice := make([]int, 10000)
					for i := 0; i < 10000; i++ {
						testSlice[i] = i
					}
					
					for i := 0; i < 10000; i++ {
						_ = testSlice[i]
					}
					
					sliceDuration := time.Since(startTime)
					log.Printf("Sliceæ“ä½œè€—æ—¶: %v", sliceDuration)
					
					// æ€§èƒ½éªŒè¯
					if mapDuration > time.Second {
						return fmt.Errorf("Mapæ“ä½œæ€§èƒ½ä¸è¶³: %v", mapDuration)
					}
					
					if sliceDuration > time.Second {
						return fmt.Errorf("Sliceæ“ä½œæ€§èƒ½ä¸è¶³: %v", sliceDuration)
					}
					
					return nil
				},
			},
		},
	}
}

// EnhancedIntegrationTests å¢å¼ºçš„é›†æˆæµ‹è¯•å¥—ä»¶
func EnhancedIntegrationTests() *TestSuite {
	return &TestSuite{
		Name: "EnhancedIntegrationTests",
		Setup: func() error {
			log.Println("è®¾ç½®å¢å¼ºé›†æˆæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		Teardown: func() error {
			log.Println("æ¸…ç†å¢å¼ºé›†æˆæµ‹è¯•ç¯å¢ƒ")
			return nil
		},
		TestCases: []TestCase{
			{
				Name: "TestConfigurationFiles",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•é…ç½®æ–‡ä»¶å­˜åœ¨æ€§å’ŒåŸºæœ¬æ ¼å¼
					
					configFiles := []string{
						"configs/agent.yaml",
						"configs/broker.yaml",
						"configs/visualization.yaml",
					}
					
					for _, configFile := range configFiles {
						// æ£€æŸ¥æ–‡ä»¶å­˜åœ¨
						if _, err := os.Stat(configFile); os.IsNotExist(err) {
							return fmt.Errorf("é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: %s", configFile)
						}
						
						// è¯»å–æ–‡ä»¶å†…å®¹
						content, err := os.ReadFile(configFile)
						if err != nil {
							return fmt.Errorf("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: %s", configFile)
						}
						
						// åŸºæœ¬éªŒè¯
						if len(content) == 0 {
							return fmt.Errorf("é…ç½®æ–‡ä»¶ä¸ºç©º: %s", configFile)
						}
						
						// æ£€æŸ¥åŸºæœ¬YAMLç»“æ„
						contentStr := string(content)
						if len(contentStr) < 100 {
							return fmt.Errorf("é…ç½®æ–‡ä»¶å†…å®¹è¿‡çŸ­: %s", configFile)
						}
						
						log.Printf("é…ç½®æ–‡ä»¶ %s éªŒè¯é€šè¿‡", configFile)
					}
					
					return nil
				},
			},
			{
				Name: "TestBuildArtifacts",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•æ„å»ºäº§ç‰©
					
					binaries := []string{
						"bin/agent",
						"bin/broker",
						"bin/visualization",
					}
					
					for _, binary := range binaries {
						// æ£€æŸ¥äºŒè¿›åˆ¶æ–‡ä»¶å­˜åœ¨
						if _, err := os.Stat(binary); os.IsNotExist(err) {
							return fmt.Errorf("äºŒè¿›åˆ¶æ–‡ä»¶ä¸å­˜åœ¨: %s", binary)
						}
						
						// æ£€æŸ¥æ–‡ä»¶å¤§å°
						info, err := os.Stat(binary)
						if err != nil {
							return fmt.Errorf("è·å–äºŒè¿›åˆ¶æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %s", binary)
						}
						
						if info.Size() < 1000000 { // è‡³å°‘1MB
							return fmt.Errorf("äºŒè¿›åˆ¶æ–‡ä»¶è¿‡å°: %s (%d bytes)", 
								binary, info.Size())
						}
						
						log.Printf("äºŒè¿›åˆ¶æ–‡ä»¶ %s éªŒè¯é€šè¿‡ (%d bytes)", binary, info.Size())
					}
					
					return nil
				},
			},
			{
				Name: "TestProtocolFiles",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•åè®®æ–‡ä»¶
					
					protoFiles := []string{
						"proto/monitor.proto",
						"proto/monitor.pb.go",
						"proto/monitor_grpc.pb.go",
					}
					
					for _, protoFile := range protoFiles {
						if _, err := os.Stat(protoFile); os.IsNotExist(err) {
							return fmt.Errorf("åè®®æ–‡ä»¶ä¸å­˜åœ¨: %s", protoFile)
						}
						
						// æ£€æŸ¥æ–‡ä»¶å†…å®¹
						content, err := os.ReadFile(protoFile)
						if err != nil {
							return fmt.Errorf("è¯»å–åè®®æ–‡ä»¶å¤±è´¥: %s", protoFile)
						}
						
						if len(content) == 0 {
							return fmt.Errorf("åè®®æ–‡ä»¶ä¸ºç©º: %s", protoFile)
						}
						
						log.Printf("åè®®æ–‡ä»¶ %s éªŒè¯é€šè¿‡", protoFile)
					}
					
					return nil
				},
			},
			{
				Name: "TestSystemIntegration",
				TestFunc: func(t *testing.T) error {
					// æµ‹è¯•ç³»ç»Ÿé›†æˆ
					
					// æ£€æŸ¥å¿…è¦çš„ç›®å½•
					requiredDirs := []string{
						"agent",
						"broker",
						"visualization",
						"proto",
						"configs",
						"test",
					}
					
					for _, dir := range requiredDirs {
						if _, err := os.Stat(dir); os.IsNotExist(err) {
							return fmt.Errorf("å¿…è¦ç›®å½•ä¸å­˜åœ¨: %s", dir)
						}
					}
					
					// æ£€æŸ¥å…³é”®æ–‡ä»¶
					keyFiles := []string{
						"Makefile",
						"go.mod",
						"go.sum",
						"README.md",
					}
					
					for _, file := range keyFiles {
						if _, err := os.Stat(file); os.IsNotExist(err) {
							return fmt.Errorf("å…³é”®æ–‡ä»¶ä¸å­˜åœ¨: %s", file)
						}
					}
					
					log.Printf("ç³»ç»Ÿé›†æˆéªŒè¯é€šè¿‡")
					return nil
				},
			},
		},
	}
}

// RunEnhancedTests è¿è¡Œå¢å¼ºæµ‹è¯•
func RunEnhancedTests() error {
	runner, err := NewTestRunner()
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæµ‹è¯•è¿è¡Œå™¨å¤±è´¥: %v", err)
	}
	defer runner.Close()
	
	// æ·»åŠ æ‰€æœ‰æµ‹è¯•å¥—ä»¶
	runner.AddSuite(EnhancedAgentTests())
	runner.AddSuite(EnhancedBrokerTests())
	runner.AddSuite(EnhancedPerformanceTests())
	runner.AddSuite(EnhancedIntegrationTests())
	
	// è¿è¡Œæµ‹è¯•
	results := runner.Run()
	
	// ç»Ÿè®¡ç»“æœ
	total := len(results)
	passed := 0
	failed := 0
	
	for _, result := range results {
		if result.Passed {
			passed++
		} else {
			failed++
		}
	}
	
	// è¾“å‡ºç»“æœ
	fmt.Printf("\n=== å¢å¼ºæµ‹è¯•ç»“æœæ±‡æ€» ===\n")
	fmt.Printf("æ€»æµ‹è¯•æ•°: %d\n", total)
	fmt.Printf("é€šè¿‡: %d\n", passed)
	fmt.Printf("å¤±è´¥: %d\n", failed)
	fmt.Printf("æˆåŠŸç‡: %.1f%%\n", float64(passed)/float64(total)*100)
	
	if failed > 0 {
		fmt.Printf("\nå¤±è´¥çš„æµ‹è¯•:\n")
		for _, result := range results {
			if !result.Passed {
				fmt.Printf("- %s.%s: %v\n", result.SuiteName, result.TestCase, result.Error)
			}
		}
		return fmt.Errorf("æœ‰%dä¸ªæµ‹è¯•å¤±è´¥", failed)
	}
	
	fmt.Printf("\nğŸ‰ æ‰€æœ‰å¢å¼ºæµ‹è¯•é€šè¿‡ï¼\n")
	return nil
}