## 技术选型与使用说明

本文件概述监控系统所采用的关键技术、使用位置、使用方式与选择原因，便于快速理解整体技术架构与取舍。

### gRPC（远程过程调用）
- 使用位置：`agent` ↔ `broker`、`visualization` ↔ `broker` 的服务接口与数据传输；对应目录 `agent/internal/service/`、`broker/internal/service/`、`proto/`。
- 如何使用：基于 Protocol Buffers 定义消息与服务接口，Agent 通过流式 RPC 持续上报指标；Visualization 通过 RPC 查询聚合/历史数据。
- 为什么用：
  - 高性能二进制协议、连接复用、流式语义适合指标上报与查询。
  - 强类型契约降低联调成本；配套生态完善（负载、拦截器、压缩、限流）。

### Protocol Buffers（消息序列化）
- 使用位置：`proto/` 定义所有跨服务数据结构与 RPC 服务；生成代码被 `agent`、`broker`、`visualization` 共同依赖。
- 如何使用：通过 `.proto` 声明指标数据、请求与响应消息；使用生成器生成各语言绑定；随 gRPC 流式传输。
- 为什么用：
  - 高压缩比、向后兼容字段演进、跨语言一致性好。
  - 生成代码可靠且性能稳定，适合高吞吐实时场景。

### Redis（热数据存储与缓存）
- 使用位置：`broker/internal/storage/`，存储分片后的监控指标、查询缓存与元数据缓存。
- 如何使用：结合一致性哈希将不同主机/指标路由到 Redis 分片；对热数据设置 TTL；对窗口聚合结果进行短期缓存以加速查询。
- 为什么用：
  - 内存级低延迟与丰富数据结构，满足高并发读写与快速过期的需求。
  - 支持 Cluster 模式横向扩展；便于实现读写分离与高可用。

### Raft（分布式一致性）
- 使用位置：`broker/internal/raft/`，用于集群元数据、领导者选举与关键状态的强一致管理。
- 如何使用：通过 Raft 日志复制与快照保持 Broker 集群一致；Leader 负责写路径仲裁，Follower 接收复制并用于故障切换。
- 为什么用：
  - 保证强一致前提下的可用性与容错（N/2+1）；简化一致性问题的边界与实现复杂度。

### 一致性哈希（数据分片与均衡）
- 使用位置：`broker/internal/hash/`，为主机或指标键计算落点；`visualization` 侧查询路由按相同规则定位分片。
- 如何使用：通过虚拟节点提升分布均匀性；扩缩容时仅迁移少量键，减少数据迁移成本与抖动。
- 为什么用：
  - 自然适配监控数据键空间大、分布随规模变动的特点；迁移量可控，利于平滑扩缩容。

### WebSocket（浏览器实时推送）
- 使用位置：`visualization/internal/websocket/`，面向浏览器进行实时指标推送。
- 如何使用：服务端维护会话与订阅，按主题/主机增量推送；对慢消费者采用背压或降采样策略。
- 为什么用：
  - 浏览器端通用、双向通信与低开销常驻连接，适合实时可视化。

### QUIC（可选的高性能传输）
- 使用位置：`visualization/internal/quic/`，在弱网或移动网络中提升实时链路抗抖动能力。
- 如何使用：利用多路复用与 0-RTT 连接复用，减少建连与队头阻塞；必要时与 WebSocket 并行作为旁路通道。
- 为什么用：
  - 更好的弱网体验与抖动容忍，降低重传带来的端到端延迟。


### C 无锁队列（基于环形数组的CAS队列）
- 使用位置：`agent` 侧 C 模块，与采集器配合进行内存内高效缓冲与批处理。
- 如何使用：C层使用CAS操作的环形队列，Go层有mutex包装保护；支撑高频采集与突发上报；结合批量打包降低 RPC 次数。
- 为什么用：
  - C层消除锁争用，使用原子操作；环形数组结构，容量可配置；Go包装器提供类型安全。

### C epoll 服务器（高并发网络 I/O）
- 使用位置：网络 I/O 关键路径的高并发场景（可作为扩展模块接入）。
- 如何使用：基于 epoll 边缘触发处理大量长连接；与 Go 侧通过 CGO 桥接，避免频繁跨语言边界。
- 为什么用：
  - 在极端连接数/事件风暴场景下降低调度与系统调用开销，提升可预期性。

### C++ Top-K 算法（实时分析）
- 使用位置：`visualization/internal/topk/`，用于热点主机/指标的实时排名与异常检测。
- 如何使用：在窗口聚合后计算 Top-K，按订阅推送结果；对大基数场景使用近似算法权衡精度与性能。
- 为什么用：
  - 实时分析对延迟极敏感，C++ 算法在相同资源下提供更高吞吐与更低延迟。

### CGO 跨语言集成
- 使用位置：`agent` 与 `visualization` 的性能关键路径，将 C/C++ 模块与 Go 业务逻辑组合。
- 如何使用：将热路径封装为稳定的窄接口，通过批量化调用降低跨语言开销；在边界进行内存与错误语义转换。
- 为什么用：
  - 兼顾开发效率与极致性能：Go 负责并发与业务编排，C/C++ 负责热点算子与 I/O。

### 配置与管理（YAML）
- 使用位置：`configs/agent.yaml`、`configs/broker.yaml`、`configs/visualization.yaml`。
- 如何使用：组件启动时加载配置，控制采集频率、分片策略、端口、认证参数、连接限额等；支持按环境覆盖。
- 为什么用：
  - 显式化可运维参数，易于审计与灰度调整；不需改动代码即可调整性能与功能边界。

### 关键取舍与替代方案
- gRPC vs REST：在高频、流式与强类型契约场景下优先 gRPC；REST 可作为管理与低频查询的补充。
- Redis vs TSDB：Redis 负责热数据实时性；历史冷数据可下沉对象存储或 TSDB，以平衡成本与查询体验。
- WebSocket vs QUIC：默认 WebSocket 兼容性最好；弱网与多路复用诉求明显时启用 QUIC。
- 强一致 vs 最终一致：集群控制面采用 Raft 强一致；监控数据读侧允许近实时弱一致以提升可用与吞吐。

### 参考目录
- `agent/internal/collector/` 指标采集
- `agent/internal/algorithm/` 采集端轻量算法
- `broker/internal/{hash,raft,service,storage}/` 分片、一致性、服务与存储
- `visualization/internal/{auth,quic,radix,service,topk,websocket}/` 鉴权、传输、路由、分析与推送
- `proto/` 跨服务契约


